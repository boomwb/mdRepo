## 通讯:

### 单工/半双工/全双工/异步同步

**单工**，即数据传输只在一个方向上传输，只能你给我发送或者我给你发送，方向是固定的，不能实现双向通信，如：室外天线电视、调频广播等。

**半双工**比单工先进一点，传输方向可以切换，允许数据在两个方向上传输，但是某个时刻，只允许数据在一个方向上传输，可以基本双向通信，如：对讲机，IIC通信。

**全双工**，允许数据同时在两个方向传输。发送和接收完全独立，在发送的同时可以接收信号，或者在接收的同时可以发送。它要求发送和接收设备都要有独立的发送和接收能力，如：电话通信，SPI通信，串口通信。

串行通信可以分为两种类型，一种叫同步通信，另一种叫异步通信。

简单的说，就是同步通信需要时钟信号，而异步通信不需要时钟信号。

- 同步：发送方发出数据后，等接收方发回响应以后才发下一个数据包的通讯方式。
- 异步：发送方发出数据后，不等接收方发回响应，接着发送下个数据包的通讯方式。

SPI和IIC为同步通信，UART为异步通信，而USART为同步&异步通信。

- USART：通用同步和异步收发器
- UART：通用异步收发器

即USART支持同步和异步收发，而UART只支持异步收发。

如STM32的串口工作在同步模式时，即智能卡模式时，就需要连接同步时钟引脚。

### 串口通讯



奇偶检验等N、O、E、M、S 五种串口检验位类型

![image-20240515142834135](https://raw.githubusercontent.com/boomwb/mdRepo/main/202405151428201.png)

![image-20240515142939595](https://raw.githubusercontent.com/boomwb/mdRepo/main/202405151429660.png)















### IIC

对于通讯协议，我们也以分层的方式来理解，最基本的是把它分为物理层和协议层。物理层规定通讯系统中具有机械、电子功能部分的特性，确保原始数据在物理媒体的传输。协议层主要规定通讯逻辑，统一收发双方的数据打包、解包标准。

**I2c物理层**

![image-20240515143041820](https://raw.githubusercontent.com/boomwb/mdRepo/main/202405151430889.png)



**I2c协议层**

I2C 的协议定义了通讯的起始和停止信号、数据有效性、响应、仲裁、时钟同步和地址广播等环节。

![image-20240515143103938](https://raw.githubusercontent.com/boomwb/mdRepo/main/202405151431001.png)



其中 S 表示由主机的 I2C 接口产生的传输起始信号 (S)，这时连接到 I2C 总线上的所有从机都会接收到这个信号。
起始信号产生后，所有从机就开始等待主机紧接下来广播的从机地址信号 (SLAVE_ADDRESS)。在 I2C 总线上，每个设备的地址都是唯一的，当主机广播的地址与某个设备地址相同时，这个设备就被选中了，没被选中的设备将会忽略之后的数据信号。根据 I2C 协议，这个从机地址可以是7 位或 10 位。
在地址位之后，是传输方向的选择位，该位为 0 时，表示后面的数据传输方向是由主机传输至从机，即主机向从机写数据。该位为 1 时，则相反，即主机由从机读数据。从机接收到匹配的地址后，主机或从机会返回一个应答 (ACK) 或非应答 (NACK) 信号，只有接收到应答信号后，主机才能继续发送或接收数据。

 **1.通讯的起始和停止信号**

当 SCL 线是高电平时 SDA 线从高电平向低电平切换，这个情况表示通讯的起始。当 SCL 是高电平时 SDA 线由低电平向高电平切换，表示通讯的停止。起始和停止信号一般由主机产生。

![image-20240515143131041](https://raw.githubusercontent.com/boomwb/mdRepo/main/202405151431082.png)





**2.数据有效性**

I2C 使用 SDA 信号线来传输数据，使用 SCL 信号线进行数据同步。

SDA 数据线在 SCL 的每个时钟周期传输一位数据.传输时，SCL 为高电平的时候 SDA 表示的数据有效,此时SDA的电平高低分别表示数据1/数据0。当 SCL 为低电平时，SDA的数据无效，一般在这个时候 SDA 进行电平切换，为下一次表示数据做好准备。每次数据传输都以字节为单位，每次传输的字节数不受限制。：

![image-20240515143150543](https://raw.githubusercontent.com/boomwb/mdRepo/main/202405151431583.png)



**3.地址及数据方向**

主机发起通讯时，通过 SDA 信号线发送设备地址来查找从机。

I2C 协议规定设备地址可以是 7 位或 10 位，紧跟设备地址的一个数据位用来表示数据传输方向，它是数据方向位 （R或者/W），第 8位或第 11 位。数据方向位为“1”时表示主机由从机读数据，该位为“0”时表示主机向从机写数据。

读数据方向时，主机会释放对 SDA 信号线的控制，由从机控制 SDA 信号线.主机接收信号.

写数据方向时，SDA 由主机控制，从机接收信号。

![image-20240515143221936](https://raw.githubusercontent.com/boomwb/mdRepo/main/202405151432968.png)



**4.响应**

传输时主机产生时钟，在第 9 个时钟时，数据发送端会释放 SDA 的控制权，由数据接收端控制SDA，若 SDA 为高电平，表示非应答信号 (NACK)，低电平表示应答信号 (ACK)。



![image-20240515143248928](https://raw.githubusercontent.com/boomwb/mdRepo/main/202405151432982.png)

[100](#jump)



32.768KHZ

实时时钟晶振为什么选择是32768Hz的晶振，在百度上搜索的话大部分的答案都是说2的15次方是32768，使用这个频率的晶振，人们可以很容易的通过分频电路得到1Hz的计时脉冲。但是话有说回来了，2的整数次方很多为什么偏偏选择15呢？

  2的15次方正好等于32768，反过来讲，如果要把32.768K的时钟频率经过15次分频的话，得到的频率正好是1Hz。

以下是关于时钟晶振频率选择所需要考虑的几点： 

1.频度越高计时精度越高，误差越小。

2.由于各种原因，每个晶振的实际频率与其标称频率之间也存在偏差。

3.晶振的工作环境对晶振的频率也有影响，用晶振的频率稳定度来表示不同晶振受环境影响的大小，其单位是ppm（百万分之一） 

4.通常工作频率越高，单片机等数字电路的功耗越大，32.768KHz这个频率比较低，对降低电路功耗有利。 

5.晶振的 32.768KHZ是大于20Khz(人耳听力上限)的第一个2的整幂数。



## FLASH

### 内部FLASH

#### 理论

1.解锁

内部 FLASH 空间主要存储的是应用程序，是非常关键的数据，为了防止误操作修改了这些内容，芯片复位后默认会给控制寄存器 FLASH_CR 上锁，这个时候不允许设置 FLASH 的控制寄存器，从而不能修改 FLASH 中的内容。
所以对 FLASH 写入数据前，需要先给它解锁。解锁的操作步骤如下：
(1) 往 FPEC 键寄存器 FLASH_KEYR 中写入 KEY1 = 0x45670123
(2) 再往 FPEC 键寄存器 FLASH_KEYR 中写入 KEY2 = 0xCDEF89AB

2.页擦除

在写入新的数据前，需要先擦除存储区域，STM32 提供了页（扇区）擦除指令和整个 FLASH 擦除 (批量擦除) 的指令，批量擦除指令仅针对主存储区。                          页擦除的过程如下：
(1) 检查 FLASH_SR 寄存器中的“忙碌寄存器位 BSY”，以确认当前未执行任何 Flash 操作；
(2) 在 FLASH_CR 寄存器中，将“激活页擦除寄存器位 PER ”置 1，
(3) 用 FLASH_AR 寄存器选择要擦除的页；
(4) 将 FLASH_CR 寄存器中的“开始擦除寄存器位 STRT ”置 1，开始擦除；
(5) 等待 BSY 位被清零时，表示擦除完成。

3.写入数据

擦除完毕后即可写入数据，写入数据的过程并不是仅仅使用指针向地址赋值，赋值前还还需要配
置一系列的寄存器，步骤如下：
(1) 检查 FLASH_SR 中的 BSY 位，以确认当前未执行任何其它的内部 Flash 操作；
(2) 将 FLASH_CR 寄存器中的“激活编程寄存器位 PG”置 1；
(3) 向指定的 FLASH 存储器地址执行数据写入操作，每次只能以 16 位的方式写入；
(4) 等待 BSY 位被清零时，表示写入完成。

#### 应用例子



### 外接FLASh

DMA的基本定义
DMA，全称Direct Memory Access，即直接存储器访问。

DMA传输将数据从一个地址空间复制到另一个地址空间，
提供在外设和存储器之间或者存储器和存储器之间的高速数据传输。
当CPU初始化这个传输动作，传输动作本身是由DMA控制器来实现和完成的。
DMA传输方式无需CPU直接控制传输，也没有中断处理方式那样保留现场和恢复现场过程，
通过硬件为RAM和IO设备开辟一条直接传输数据的通道，使得CPU的效率大大提高。


A=   110101x1
B=   0000 0010
~B= 1111 1101
A&=~B---->1101 0101 //把B中为1的位对应于A的同样位上置0，A的其他位不变

A=   1101 0111
B=   0000 0010
A&=B----> 0000 0010  //把A中其他位置0,

A |= B
A=0010 110x，
B=0000 0001，则执行结果为A=00101101，
也就是说A |= B是给B中为1的位对应于A的同样位上置1，A的其他位不变



启动文件由汇编(xxx.s)编写，是系统上电复位后第一个执行的程序。

主要做了以下工作：

1.初始化堆栈指针

![image-20240515143321871](https://raw.githubusercontent.com/boomwb/mdRepo/main/202405151433903.png)



	stack栈, 开辟栈的大小为 0X00000400（1KB），名字为 STACK，NOINIT 即不初始化，可读可写，8（2^3）字节对齐
	栈的作用是用于局部变量，函数调用，函数形参等的开销，栈的大小不能超过内部 SRAM 的大小。如果编写的程序比较大，定义的局部变量很多，那么就需要修改栈的大小。硬 fault 的时候，这时你就要考虑下是不是栈不够大，溢出了。

![image-20240515143352785](https://raw.githubusercontent.com/boomwb/mdRepo/main/202405151433815.png)



```
Heap堆
开辟堆的大小为 0X00000200（512 字节），名字为 HEAP，NOINIT 即不初始化，可读可写，8（2^3）字节对齐。__heap_base 表示对的起始地址，__heap_limit 表示堆的结束地址。堆是由低向高生长的，跟栈的生长方向相反。
堆主要用来动态内存的分配，像 malloc() 函数申请的内存就在堆上面。
```





2.初始化PC指针 Reset_Handler

3.初始化中断向量表 

4.配置系统时钟  SystemInit

5.调用C库函数__main初始化用户堆栈,从而最终调用main函数.

![image-20240515143411220](https://raw.githubusercontent.com/boomwb/mdRepo/main/202405151434291.png)





2024/2/20

SPI Flash 128Block

Sector  4KB(4096个地址) 1KB=1024字节

Block    64KB

页写入一次256个字节(Byte)

