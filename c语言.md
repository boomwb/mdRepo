# 进制输出

```
%o
%x
%d
```

# 关键字:

**static静态变量**

```
一、 static全局变量与普通的全局变量有什么区别 ?
全局变量(外部变量)的说明之前再冠以static 就构成了静态的全局变量。
   全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。 这两者在存储方式上并无不同。
这两者的区别在于非静态全局变量的作用域是整个源程序， 当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。 而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其它源文件中引起错误。
	static全局变量只初使化一次，防止在其他文件单元中被引用;
	
 二、static局部变量和普通局部变量有什么区别 ？
   把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围。
  static局部变量只被初始化一次，下一次依据上一次结果值
  
 所有未加static前缀的全局变量和函数都具有全局可见性，其它的源文件也能访问。如果加了static，就会对其它源文件隐藏。
   static的第二个作用是保持变量内容的持久。存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。共有两种变量存储在静态存储区：全局变量和static变量，只不过和全局变量比起来，static可以控制变量的可见范围，说到底static还是用来隐藏的.
   #include <stdio.h>
 
     int fun(void){   
         static int count = 10;    // 事实上此赋值语句从来没有执行过
         return count--;
     }
 
     int count = 1;
 
     int main(void)
     {    
         printf("global\t\tlocal static\n");
         for(; count <= 10; ++count)
             printf("%d\t\t%d\n", count, fun());    
 
         return 0;
     }
 结果为:
 global    local static
 1			10
 2			9
 3			8
 4			7
 5			6
 6			5
 7			4
 8			3
 9			2
 10			1
 
     
   static的第三个作用是默认初始化为0。其实全局变量也具备这一属性，因为全局变量也存储在静态数据区。在静态数据区，内存中所有的字节默认值都是0x00，某些时候这一特点可以减少程序员的工作量。比如初始化一个稀疏矩阵，我们可以一个一个地把所有元素都置0，然后把不是0的几个元素赋值。如果定义成静态的，就省去了一开始置0的操作。再比如要把一个字符数组当字符串来用，但又觉得每次在字符数组末尾加’\0’太麻烦。如果把字符串定义成静态的，就省去了这个麻烦，因为那里本来就是’\0’。
	
```



**extern**

```
extern int a;
常在.h文件中
显式的声明了a的存储空间是在程序的其他地方分配的，在文件中其他位置或者其他文件中寻找a这个变量。

static 表示静态的变量，限制此变量作用域在一个源文件内，其他文件不能用extern来引用此变量，不仅适用于变量，函数也可以.
```

**const char * **

```
一.const char *s  ||   char const *s
是指向常量的指针,*s是不变的, s是可以改变的
s所指向的数据(即*s)由于const的修饰而不可通过指针s去修改。

二.char *const s
s是个不可修改的指针，但可通过指针s去修改s所指向的数据(即*s)。

```



# 函数指针

指向函数的指针变量

int ()



# 大小端

#### 一、什么是大小端？

对于一个由2个字节组成的16位整数，在[内存](https://so.csdn.net/so/search?q=内存&spm=1001.2101.3001.7020)中存储这两个字节有两种方法：一种是将低序字节存储在起始地址，这称为小端(little-endian)字节序；另一种方法是将高序字节存储在起始地址，这称为大端(big-endian)字节序。

[百度](https://baidu.com)

![image-20240429100655444](C:\Users\DELL\Desktop\Linux_code\Typora_Work\Typora_Pic\image-20240429100655444.png)

假如现有一32位int型数0x12345678，那么其MSB(Most Significant Byte，最高有效字节)为0x12，其LSB (Least Significant Byte，最低有效字节)为0x78，在CPU内存中有两种存放方式：（假设从地址0x4000开始存放）

![image-20240429100727689](C:\Users\DELL\Desktop\Linux_code\Typora_Work\Typora_Pic\image-20240429100727689.png)

**总结：**

**大端是高字节存放到内存的低地址**

**小端是高字节存放到内存的高地址**

#### 二、如何确定大小端

有些CPU公司用大端（譬如C51单片机）；有些CPU用小端（譬如ARM）。（大部分是用小端模式，大端模式的不算多）。于是乎我们写代码时，当不知道当前环境是用大端模式还是小端模式时就需要用代码来检测当前系统的大小端。下面给出用程序判断大小端的两种方法：

```
#include <stdio.h>
 
// 共用体中很重要的一点：a和b都是从u1的低地址开始存放的。
// 假设u1所在的4字节地址分别是：0、1、2、3的话，那么a自然就是0、1、2、3；
// b所在的地址是0而不是3.
 
union myunion
{
	int a;
	char b;
};
 
// 如果是小端模式则返回1，小端模式则返回0
int is_little_endian(void)
{
	union myunion u1;
	u1.a = 0x12345678;				// 地址0的那个字节内是0x78（小端）或者0x12（大端）
    if(0x78 == u1.b)
        return 1;
    else if(0x12 == u1.b)
	    return 0;
}
 
int is_little_endian2(void)
{
	int a = 0x12345678;
	char b = *((char *)(&a));		// 指针方式其实就是共用体的本质
	if(0x78 == b)
        return 1;
    else if(0x12 == b)
	    return 0;
}
 
 
int main(void)
{
	int i = is_little_endian2();
	//int i = is_little_endian();
	if (i == 1)
	{
		printf("小端模式\n");
	}
	else
	{
		printf("大端模式\n");
	}
	
	return 0;
}

```



下面给出三种确定大小端错误的方案:

```
	// 强制类型转换
int a;
char b;
a = 1;
b = (char)a;
printf("b = %d.\n", b);
```

```
	// 移位
int a, b;
a = 1;
b = a >> 1;
printf("b = %d.\n", b);
```

```
	// 位与
int a = 1;
int b = a & 0xff;		// 也可以写成：char b = a & 0x01;
printf("b = %d.\n", b);
```

位与、移位、强制类型转换等运算是编译器提供的运算，这个运算是高于内存层次的（或者说这些运算在二进制层次具有可移植性，也就是说&的时候一定是高字节&高字节，低字节&低字节，和二进制存储无关）。

#### **怎么测试我的电脑是小端模式还是大端模式呢？**

1.将int 48存起来，然后取得其地址，再将这个地址转为char* 这时候，如果是小端存储，那么char*指针就指向48；
48对应的ASCII码为字符‘0’；

```
void judge_bigend_littleend1()
{
    int i = 48;
    int* p = &i;
    char c = 0;
    c = *((char*)p);

    if (c == '0')
        printf("小端\n");
    else
        printf("大端\n");
}
```

2.定义变量int i=1;将 i 的地址拿到，强转成char*型，这时候就取到了 i 的低地址，这时候如果是1就是小端存储，如果是0就是大端存储.

```
void judge_bigend_littleend2()
{
    int i = 1;
    char c = (*(char*)&i);

    if (c)
        printf("小端\n");
    else
        printf("大端\n");
}
```

3.定义联合体，一个成员是多字节，一个是单字节，给多字节的成员赋一个最低一个字节不为0，其他字节为0 的值，再用第二个成员来判断，如果第二个字节不为0，就是小端，若为0，就是大端。

```
void judge_bigend_littleend3()
{
    union
    {
        int i;
        char c;
    }un;
    un.i = 1;

    if (un.c == 1)
        printf("小端\n");
    else
        printf("大端\n");
}
```

