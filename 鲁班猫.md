> www.c
>
> fkf
>
> 

```
sudo apt install gcc make git bc libssl-dev \
liblz4-tool device-tree-compiler bison flex \
u-boot-tools gcc-aarch64-linux-gnu


```



# linux指令--网络

```c++
重启网络Ubuntu:
sudo service network-manager stop
sudo rm /var/lib/NetworkManager/NetworkManager.state 
sudo service network-manager start
```

```
sudo passwd lubancat
sudo passwd root
su root   /  sudo -i
su lubancat
```

```
insmod
lsmod
rmmod
dmesg 命令主要用来显示内核信息。使用 dmesg 可以有效诊断机器硬件故障或者添加硬件出现的问题。另外，使用 dmesg 可以确定您的服务器安装了哪些硬件。每次系统重启，系统都会检查所有硬件并将信息记录下来。执行/bin/dmesg 命令可以查看该记录，开机信息亦保存在/var/log目录中，名称为dmesg的文件里。

```









## LubanCat2 金手指底板

```
1，常用。
无序列表：Shift+Alt+W
有序列表：Ctrl+Shift+[
任务列表：-空格[空格]空格 文字或者Shift+Alt+R
标题：Ctrl+数字
表格：Ctrl+t
生成目录：[TOC]按回车
选中一整行：Ctrl+l
选中单词：Ctrl+d
选中相同格式的文字：Ctrl+e
跳转到文章开头：Ctrl+home
跳转到文章结尾：Ctrl+end
搜索：Ctrl+f
替换：Ctrl+h
引用：输入>之后输入空格或者Ctrl+Shift+q
代码块：Shift+Alt+C
加粗：Ctrl+b
倾斜：Ctrl+i
下划线：Ctrl+u
删除线：Alt+shift+5
插入图片：直接拖动到指定位置即可或者Ctrl+Shift+i
插入链接：Ctrl + k
增大列表缩进：Ctrl + [
减小列表缩进：Ctrl + ]
分隔线：三个小横杠然后回车
#2，其他。
#1，下标
H~2~O 显示为 H₂O 。

#2，上标
X^2^ 显示为 X² 。

#3，表情
首先输入一个 :然后输入关键词会进行扩展
```

















是野火科技基于 LubanCat-2M 核心板设计的一款全功能底板。

![image-20231021105254636](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20231021105254636.png)

![image-20231021144703729](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20231021144703729.png)

![image-20231021145008792](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20231021145008792.png)



### NFS与SCP与ssh_code

![](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20231023134817423.png)

![image-20231023161814408](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20231023161814408.png)

```c
//开发板运行,ip是主机ip
sudo mount -t nfs 192.168.137.63:/home/lubancat/workdir /mnt

```

SCP:

```c
在ubuntu上执行:
scp file_name cat@板子ip(192.168.0.0) :/home/cat/liu(板子文件夹)
scp -r 传文件夹

```



ssh_vscode

```
ssh lubancat@10.230.13.155 -A
```



将系统运行的信息都记录在/proc 目录下的文
件中，用户可以通过访问该目录下的文件获取对应的系统信

与/proc 目录类似，/sys 目录下的文件/文件夹向用户提供了一些关于设备、内核模块、文件系统以
及其他内核组件的信息，如子目录 block 中存放了所有的块设备；子目录 bus 中存放了系统中所
有的总线类型，有 i2c、usb、sdio、pci 等；子目录 class 按类型归类设备，如 leds、lcd、mtd、pwm
等。

除了/proc 和/sys 目录外，/dev 目录也包含了非常丰富的设备信息，该目录下包含了 Linux 系统中
使用的所有外部设备，如/dev/tty 为串口设备、/dev/ram 为内存、通过这些设备文件，我们也可以
访问到对应的硬件设备。



### GPIO命名

Rockchip Pin 的 ID 按照控制器 (bank)+ 端口 (port)+ 索引序号 (pin) 组成。

rk356x 具有 5 个 GPIO 控制器，每个控制器可以控制 32 个 IO

..控制器和 GPIO 控制器数量一致
• 端口固定 A、B、C 和 D，每个端口仅有 8 个索引号,(a=0,b=1,c=2,d=3)
• 索引序号固定 0、1、2、3、4、5、6、7

GPIO1_A4 表达的意思为第 1 组控制器，端口号为 A，索引号为 4。该引脚号的计算公式为 32 x1 + 0 x 8 + 4 = 36

RK3568 中引脚用 GPIO 编号，复用型引脚分为 5 组 (GPIO0~4)，每组里面都有 32 个复
用型引脚，而且又分为 4 个小组 (A、B、C、D)，每个小组 8 个引脚 (0~7)。例如：GPIO0_C7 是
GPIO0 大组，第 3 个小组，第 8 个引脚。

### 驱动环境

/home/lubancat/LubanCat_SDK/kernel/

需要下载源码内核源码或者对应内核头文件 (Kernel Headers),编译源码、编译驱动模块以及设备树等，最终将驱动模块和设备树拷贝到开发板上运行。

，驱动模块是具有独立功能的程序，它可以被单独编译，但不能独立运行，在运行时它被链
接到内核作为内核的一部分在内核空间运行。也因此想要我们写的内核模块在某个版本的内核
上运行，那么就必须在该内核版本上编译它。

#### 内核模块

ctags -R ctrl+] ctrl+T

sudo apt-get install wine-stable

sudo apt autoremove

加载到内核，可以将内核模块编译成单独的模块，在内核启动后由用户手动动态加载，

也可以将模块直接编译进内核，在内核启动时就自动加载

内核模块全称 Loadable Kernel Module(LKM)，是一种在内

核运行时加载一组目标代码来实现某个特定功能的机制。

模块是具有独立功能的程序，它可以被单独编译，但不能独立运行，在运行时它被链接到内核作

为内核的一部分在内核空间运行，这与运行在用户空间的进程是不一样的。模块由一组函数和数

据结构组成，用来实现一种文件系统、一个驱动程序和其他内核上层功能。因此内核模块具备如

下特点：

• **模块本身不被编译入内核映像，这控制了内核的大小**。

• **模块一旦被加载，它就和内核中的其它部分完全一样**。

成.ko 为后缀的 ELF 文件。我们可以使用 file 命令来查

看它。

ko 文件在数据组织形式上是 ELF(Excutable And Linking Format) 格式，是一种普通的可重定位目

标文件。这类文件包含了代码和数据，可以被用来链接成可执行文件或共享目标文件，静态链接

库也可以归为这一类。

 sudo vim /etc/exports 

![image-20231023141924768](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20231023141924768.png)



```
#include <linux/module.h>

#include <linux/init.h>

#include <linux/kernel.h>

static int __init hello_init(void)
{

	printk(KERN_EMERG "[ KERN_EMERG]HelloModuleInit\n");

	printk( "[ default ]HelloModule Init\n");

	return 0;
}

static void __exit hello_exit(void)
{
	printk("[ default ]HelloModule Exit\n");
}

module_init(hello_init);

module_exit(hello_exit);

MODULE_LICENSE("GPL2");

MODULE_AUTHOR("embedfire ");

MODULE_DESCRIPTION("hello module");

MODULE_ALIAS("test_module");

```





Linux 内核提供一个宏来实现模块的**参数传递**

module_param(/include/linux/module/moduleparam.h)

```
static int itype=0;
module_param(itype,int,0);

static bool btype=0;
module_param(btype,bool,0644);

static char ctype=0;
module_param(btype,byte,0);

static char *dtype=0;
module_param(dtype,charp,0644);

static int __init param_init(void)
{
	printk(KENR_ALERT "param init!\n");
	printk(KENR_ALERT "itype=%d\n",itype);
}

```



**符号**指的就是在内核模块中导出函数
和变量，在加载模块时被记录在公共内核符号表中，以供其他模块调用。这个机制，允许我们使
用分层的思想解决一些复杂的模块设计。我们在编写一个驱动的时候，可以把驱动按照功能分成
几个内核模块，借助符号共享去实现模块与模块之间的接口调用，变量共享。

**EXPORT_SYMBOL 宏用于向内核导出符号**，这样的话，其他模块也可以使用我们导出的符号了。

```
static int itype=0;
module_param(itype,int,0);

EXPORT_SYMBOL(itype);

int add_my(int a,int b)
{
	return  a+b;
}
EXPORT_SYMBOL(add_my);

int sub_my(int a,int b)
{
	return a-b;
}
EXPORT_SYMBOL(sub_my);
```







**lsmod** 列出当前内核中加载的模块，格式化显示在终端要将一个模块加载到内核中，**insmod** 是最简单的办法，insmod+ 模块完整路径就能达到目的，前提是你的模块不依赖其他模块，还要注意需要 sudo 权限。如果你不确定是否使用到其他模块的符号，你也可以尝试 

**modprobe,**当然 modprobe之前需要先用 **depmod -a** 建立模块之间的依赖关系，但值得注意的是使用 depmod -a 必须要将驱动模块放入系统驱动模块存放和配置的文件夹，否者无法管理依赖关系。

但是有些内核模块有依赖关系，不能直接用 insmod 加载，需要“前置”依赖模块加载后才能加载，**remmod,**工具仅仅是将内核中运行的模块删除，只需要传给它路径就能实现。

**modinfo** 用来显示我们在内核模块中定义的几个宏.





**file_operation** 就是把系统调用和驱动程序关联起来的关键数据结构。这个结构的每一个成员都对
应着一个系统调用。读取 file_operation 中相应的函数指针，接着把控制权转交给函数指针指向的
函数，从而完成了 Linux 设备驱动程序的工作。

在系统内部，I/O 设备的存取操作通过特定的入口点来进行，而这组特定的入口点恰恰是由设备驱动程序提供的。通常这组设备驱动程序接口是由结构 file_operations 结构体向系统说明的，它定义在 ebf_buster_linux/include/linux/fs.h 中。传统上, 一个 file_operation 结构或者其一个指针称为fops( 或者它的一些变体). 结构中的每个成员必须指向驱动中的函数, 这些函数实现一个特别的操作, 或者对于不支持的操作留置为 NULL。当指定为 NULL 指针时内核的确切的行为是每个函数不同的。



**查找**

sudo find / -name init.h

### LED点亮

GPIO4_D2

GPIO4  0xFE770000

### 根目录下

/sys目录,记录着各个设备之间的关系

/sys/bus目录下的每个子目录都是注册好了的总线类型。这里是设备按照总线类型分层放置的目录结构，每个子目录 (总线类型) 下包含两个子目录——devices 和 drivers 文件夹；其中 devices 下是该总线类型下的所有设备，而这些设备都是符号链接，它们分别指向真正的设备 (/sys/devices/下)；

/sys/devices 目录下是全局设备结构体系，记录了系统中所有设备

/sys/dev 记录所有的设备节点，但实际上都是些链接文件，同样指向
了 devices 目录下的文件。

/sys/class 目录下则是包含所有注册在 kernel 里面的设备类型，这是按照设备功能分类的设备模型，我们知道每种设备都具有自己特定的功能，比如：鼠标的功能是作为人机交互的输入，按照设备功能分类无论它挂载在哪条总线上都是归类到/sys/class/input 下。



### 设备树

```
ls -l /boot/
rk-kernel.dtb 是通过软链接的方式链接到 dtb/rk3568-lubancatxxx.dtb 这个设备树上的，所以在系统启动时会使用该设备树进行启动

切换设备树:
cd /boot
ln -sf dtb/rkXXXXX.dtb rk-kernel.dtb

配置文件:
配置文件位于 /boot/uEnv
Lubancat2-金手指 是UEnvLubancat2IO.txt
可以使用 ls -l/boot/uEnv/uEnv.txt 或者 ls -l /boot/uEnv 查看实际链接的配置文件，如下图所示


```



GPIO4_D2

GPIO4  0xFE770000

### 板卡关闭系统led驱动对led的控制

```
sudo sh -c 'echo 0 > /sys/class/leds/heartbeat/brightness'

```

```
ls -l /boot/
是:   /boot/dtb/rk3568-lubancat-2io.dtb

```

在系统上查看设备树的加载情况,

```
ls /proc/device-tree
进去led文件夹 可以发现led节点中定义的属性以及它的子节点，
```

```c
 hexdump reg
// hexdump是Linux下的一个二进制文件查看工具，它可以将二进制文件转换位ASCII、八进制、十进制、十六进制格式进行查看
```

### pinctrl子系统和GPIO子系统

1.

![image-20231102141901653](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20231102141901653.png)

2.GPIO子系统

### GIT与Makefile

```
sudo apt-get install git -y

git clone https://github.com/LubanCat/lubancat_rk_code_storage.git

GCC使用:
• -o：小写字母“o”，指定生成的可执行文件的名字，不指定的话生成的可执行文件名为 a.out。
• -E：只进行预处理，既不编译，也不汇编。
• -S：只编译，不汇编。
• -c：编译并汇编，但不进行链接。
• -g：生成的可执行文件带调试信息，方便使用 gdb 进行调试。
• -Ox：大写字母“O”加数字，设置程序的优化等级，如“-O0”“-O1”“-O2”“-O3”，数字
越大代码的优化等级越高，编译出来的程序一般会越小，但有可能会导致程序不正常运行。


# 直接编译成可执行文件
gcc hello.c -o hello

# 以上命令等价于执行以下全部操作
# 预处理，可理解为把头文件的代码汇总成 C 代码，把 *.c 转换得到 *.i 文件
gcc -E hello.c -o hello.i

# 编译，可理解为把 C 代码转换为汇编代码，把 *.i 转换得到 *.s 文件
gcc -S hello.i -o hello.s

# 汇编，可理解为把汇编代码转换为机器码，把 *.s 转换得到 *.o，即目标文件
gcc -c hello.s -o hello.o

# 链接，把不同文件之间的调用关系链接起来，把一个或多个 *.o 转换成最终的可执行文件
gcc hello.o -o hello
```

Makefile

```
targeta: targetb targetc
	ls -lh

targetb:
	touch text.txt

targetc:
	pwd

targetd:
	rm -f text.txt

```

```
#使用.PHONY 表示 targeta 是个伪目标
# 默认目标
#hello_main 依赖于 hello_main.c 和 hello_func.c 文件
hello_main: hello_main.c hello_func.c
gcc -o hello_main hello_main.c hello_func.c -I .
#clean 伪目标，用来删除编译生成的文件
.PHONY:clean
clean:
rm -f *.o hello_main

```

GNU 组织发布的软件工程代码的 Makefile，常常会有类似以上代码中定义的 clean 伪目标，用于
清除编译的输出文件。常见的还有“all”、“install”、“print”、“tar”等分别用于编译所有内容、安
装已编译好的程序、列出被修改的文件及打包成 tar 文件。虽然并没有固定的要求伪目标必须用
这些名字，但可以参考这些习惯来编写自己的 Makefile。
如果以上代码中不写“.PHONY:clean”语句，并且在目录下创建一个名为 clean 的文件，那么当
执行“make clean”时，clean 的命令并不会被执行

我们的 hello_main 目标文件本质上并不是依赖 hello_main.c 和 hello_func.c 文件，而是
依赖于 hello_main.o 和 hello_func.o，把这两个文件链接起来就能得到我们最终想要的 hello_main
目标文件。另外，由于 make 有一条默认规则，当找不到 xxx. o 文件时，会查找目录下的同名
xxx.c 文件进行编译。根据这样的规则，我们可把 Makefile 改修改如下。

```
hello_main: hello_main.o hello_func.o
	gcc -o hello_main hello.o hello_func.o
#以下是make的默认规则,可以不写
#hello_main.o: hello_main.c
#	gcc -c hello_main.c
#hello_func.o: hello_func.c
#	gcc -c hello_func.c 
```

使用变量:

定义变量的方式有以下四种：
•“=”：延时赋值，该变量只有在调用的时候，才会被赋值
•“:=”：直接赋值，与延时赋值相反，使用直接赋值的话，变量的值定义时就已经确定了。
•“?=”：若变量的值为空，则进行赋值，通常用于设置默认值。

•“+=”：追加赋值，可以往变量后面增加新的内容。
当我们想使用变量时，其语法如下：
$(变量名)

## 应用编程

c标准库带缓冲区, fopen()

linux系统调用 open,write,lseek

### 头文件目录

在 linux 中，大部分的头文件在系统的“/usr/include”目录下可以找到

```
sudo apt install locate
sudo updatedb

使用:
locate sys/stat.h
```

使用系统调用会影响系统的性能。执行系统调用时，Linux 需要从用户态切换至内核态，执行完毕再返回用户代码，所以减少系统调用能减少这方面的开销。如库函数写入数据的文件操作 fwrite 最后也是执行了 write 系统调用，如果是写少量数据的话，直接执行 write 可能会更高效，但如果是频繁的写入操作，由于 f write 的缓冲区可以减少调用 write 的次数，这种情况下使用 fwrite 能更节省时间。
• 硬件本身会限制系统调用本身每次读写数据块的大小。如针对某种存储设备的 write 函数每次可能必须写 4kB 的数据，那么当要写入的实际数据小于 4kB 时，write 也只能按 4kB 写入，浪费了部分空间，而带缓冲区的 fwrite 函数面对这种情况，会尽量在满足数据长度要求时才执行系统调用，减少空间开销。
• 也正是由于库函数带缓冲区，使得我们无法清楚地知道它何时才会真正地把内容写入到硬件上，所以在需要对硬件进行确定的控制时，我们更倾向于执行系统调用。

### GPIO子系统

GPIO 驱动子系统导出到用户空间的目录是“/sys/class/gpio”。

```
su
#导出GPIO到用户空间
echo 42 > /sys/class/gpio/export

#查看变化
ls /sys/class/gpio

# 把 gpio42 从用户空间中取消导出
echo 42 > /sys/class/gpio/unexport

export 文件：导出 GPIO，
• 该文件只能写不能读，用户向该文件写入 GPIO 的编号 N 可以向内核申请将该编号的 GPIO 导出到用户空间，若内核本身没有把该 GPIO 用于其它功能，那么在/sys/class/gpio 目录下会新增一个对应编号的 gpioN 目录，如上图一导出了 gpio42。
• unexport 文件：export 的相反操作，取消导出 GPIO，该文件同样只能写不能读。上图演示
了往 unexport 写入 42 后，gpio42 目录消失了。
• gpiochipX 目录：该目录是指 GPIO 控制器外设

```

GPIO设备属性

```
cd /sys/class/gpio/gpio42
ls -lh

```

GPIO sysfs接口控制gpio

```c
必须root
echo 42 > /sys/class/gpio/export

# 设置引脚为输入模式
echo in > /sys/class/gpio/gpio42/direction
# 读取引脚的值
cat /sys/class/gpio/gpio42/value

# 设置引脚为输出模式
echo out > /sys/class/gpio/gpio42/direction
# 设置引脚为低电平
echo 0 > /sys/class/gpio/gpio42/value
# 设置引脚为高电平
echo 1 > /sys/class/gpio/gpio42/value

# 复位引脚
echo 42 > /sys/class/gpio/unexport
```



### Input

/dev/input

```
sudo evtest
input_event结构体
struct input_event
{
	struct timerval timer;
	__u16 type;
	__u16 code;
	__s32 value;
};
 time：该变量用于记录事件产生的时间戳，既 evtest 输出的 time 值。
• type：输入设备的事件类型。系统常用的默认类型有 EV_KEY、EV_REL 和 EV_ABS，分别用于表示按键状态改变事件、相对坐标改变事件及绝对坐标改变事件，特别地，EV_SYN 用于分隔事件，无特别意义。如果选择鼠标（本章第一个图）evtest 输出的 type 类型为 EV_ABS。
相关的枚举值可以参考内核文件 include/uapi/linux/input-event-codes.h。
• code：事件代号，它以更精确的方式表示事件。例如在 EV_KEY 事件类型中，code 的值常用于表示键盘上具体的按键，其取值范围在 0~127 之间，例如按键 Q 对应的是 KEY_Q，该枚举变量的值为 16。如果选择鼠标，evtest 输出内容的 code 分别有 ABS_X/ABS_Y，表示上报的是 X 或 Y 坐标。
• value：事件的值。对于 EV_KEY 事件类型，当按键按下时，该值为 1；按键松开时，该值为 0。如果选择鼠标，中 evtest 输出的内容里，ABS_X 事件类型中的 value 值表示 X 坐标，ABS_Y 类型中的 value 值表示 Y 坐标。

exdump 命令来查看输出的命令
hexdump /dev/input/
```

**由于/dev下的设备都是通过/sys导出的,所以也可以通过/sys/class/input查看**

```
按键检测
在输入事件检测的应用中，通常使用主线程直接循环读取“/dev/input/event*”设备文件获取事件
的数据结构，然后通过消息队列通知其它子线程，从而响应输入操作。

```

### 串口

#### 串口结构体

```
struct termios 
{
    tcflag_t c_iflag; /* input mode flags */
    tcflag_t c_oflag; /* output mode flags */
    
    tcflag_t c_cflag; /* control mode flags */
    tcflag_t c_lflag; /* local mode flags */
    
    cc_t c_line; /* line discipline */
    cc_t c_cc[NCCS]; /* control characters */
    
    speed_t c_ispeed; /* input speed */
    speed_t c_ospeed; /* output speed */
    #define _HAVE_STRUCT_TERMIOS_C_ISPEED 1
    #define _HAVE_STRUCT_TERMIOS_C_OSPEED 1
};

c_iflag：输入（input）模式标志，用于控制如何对串口输入的字符进行处理
选项值    作用
INPCK  	启用输入奇偶检测
IGNPAR  忽略帧错误和奇偶检验错误
IGNCR    忽略输入中的回车
IXON     开启 XON/XOFF 流控制
IXOFF    关闭 XON/XOFF 流控制


c_oflag：输出（output）模式标志，用于控制串口的输出模式，常用的选项值见下表。
表 c_oflag 选项值

 c_cflag：控制（control）模式标志，用于控制串口的基本参数，如数据位、停止位等，常用
配置见下表，特别地，c_cflag 结构体成员还包含了波特率的参数。

 c_lflag：本地（local）模式标志，主要用于控制驱动程序与用户的交互，在串口通信中，实
际上用不到该成员变量。

c_cc[NCCS]：该数组包含了终端的所有特殊字符，可以修改特殊字符对应的键值（Ctrl+C
产生的 ^C，ASCII 码为 0x03），

c_ispeed 和 c_ospeed：记录串口的输入和输出波特率（input speed 和 output speed），部分可
取值如下代码所示，宏定义中的数字以“0”开头，在 C 语言中这是表示 8 进制数字的方式。

```

```
192.168.104.85 
```

# 字符设备驱动

## 1.cdev结构体

’c’用来标识字符设备，’b’用来标识块设备

```
cdev记录了字符设备的相关信息 (设备号、内核对象)，字符设备的打开、读写、关闭等操作接口(file_operations)，在我们想要添加一个字符设备时，就是将这个对象注册到内核中，通过创建一个文件 (设备节点) 绑定对象的 cdev，当我们对这个文件进行读写操作时，就可以通过虚拟文件系统，在内核中找到这个对象及其操作接口，从而控制设备。

在硬件层，我们可以通过查看硬件的原理图、芯片的数据手册，确定底层需要配置的寄存器，这类似于裸机开发，将对底层寄存器的配置，读写操作放在文件操作接口里面，也就是实现file_operations 结构体；

在驱动层，我们将文件操作接口注册到内核，内核通过内部散列表来登记记录主次设备号；
在文件系统层，新建一个文件绑定该文件操作接口，应用程序通过操作指定文件的文件操作接口来设置底层寄存器。
```

## 2.设备节点

设备节点 (设备文件)：Linux 中设备节点是通过“mknod”命令来创建的。一个设备节点其实就是一个文件，Linux 中称为设备文件。

设备节点被创建在/dev 下，是连接内核与用户层的枢纽，就是设备是接到对应哪种接口的哪个 ID上。相当于硬盘的 inode 一样的东西，记录了硬件设备的位置和信息在 Linux 中，所有设备都以文件的形式存放在/dev 目录下，都是通过文件的方式进行访问，**设备节点是 Linux 内核对设备的抽象，一个设备节点就是一个文件。**应用程序通过一组标准化的调用执行访问设备，这些调用独立于任何特定的驱动程序。而驱动程序负责将这些标准调用映射到实际硬件的特有操作。

## 3.数据结构

### 1.file_operations结构体

file_operation 就是把系统调用和驱动程序关联起来的关键数据结构。这个结构的每一个成员都对应着一个系统调用。读取file_operation 中相应的函数指针，接着把控制权转交给函数指针指向的函数，从而完成了 Linux 设备驱动程序的工作。

### 2.file结构体

内核中用 file 结构体来表示每个打开的文件，每打开一个文件，内核会创建一个结构体，并将对该文件上的操作函数传递给该结构体的成员变量 f_op，当文件所有实例被关闭后，内核会释放这个结构体.

```
struct file
{
    {.......}
    const struct file_operations *f_op;
    void *private_data;//该指针变量只会用于设备驱动程序中，内核并不会对该成员进行操作。因此，在驱动程序中，通常用于指向描述设备的结构体
    {......}
};
```

### 3.inode结构体

VFS inode 包含文件访问权限、属主、组、大小、生成时间、访问时间、最后修改时间等信息。它是Linux 管理文件系统的最基本单位，也是文件系统连接任何子目录、文件的桥梁。内核使用 inode结构体在内核内部表示一个文件。因此，它与表示一个已经打开的文件描述符的结构体 (即 file文件结构) 是不同的，我们可以使用多个 file 文件结构表示同一个文件的多个文件描述符，但此时，所有的这些 file 文件结构全部都必须只能指向一个 inode 结构体。inode 结构体包含了一大堆文件相关的信息.....

```
struct inode
{
	dev_t   i_rdev;
	{.....}
	union 
	{
		struct pipe_inode_info  *i_pipe;//linux内核管道
		struct block_device     *i_bdev ;
		struct cdev				*i_cdev; 
		char 					*i_link;
		unsigned 				i_dir_seq;
	}

};
```

## 4.字符设备驱动框架

我们创建一个字符设备的时候，首先要有一个设备号，分配设备号的途径有静态分配和动态分配；拿到设备的唯一 ID，我们需要实现 file_operation 并保存到 cdev 中，实现 cdev 的初始化；然后我们需要将我们所做的工作告诉内核，使用 cdev_add() 注册 cdev；最后我们还需要创建设备节点，以便我们后面调用 file_operation 接口。

注销设备时我们需释放内核中的 cdev，归还申请的设备号，删除创建的设备节点。

静态分配

```
int register_chrdev_region(dev_t , unsigned count, const char *name)
count-->设备号 个数
name   指定该设备的名称,可在/proc/devices中看到该设备
返回值：返回 0 表示申请成功，失败则返回错误码
```

动态

```
int alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count,␣
const char *name)
baseminor: 次设备号的起始值,通常设置为0
```

内联函数，它不仅支持静态申请设备号，也支持动态申请设备号，并将主设备号返回

```
static inline int register_chrdev(unsigned int major, const char *name,
const struct file_operations *fops)
{
	return __register_chrdev(major, 0, 256, name, fops);
}
返回值：主设备号
```

设备节点的创建与销毁:

(1).创建一个设备并将其注册到文件系统:

```
struct device *device_create(struct class *class, struct device *parent,dev_t devt, void *drvdata, const char *fmt, ...)
参数：
• class：指向这个设备应该注册到的 struct 类的指针；
• parent：指向此新设备的父结构设备 (如果有) 的指针；
• devt：要添加的 char 设备的开发；
• drvdata：要添加到设备进行回调的数据；
• fmt：输入设备名称。
返回值：成功时返回 struct device 结构体指针, 错误时返回 ERR_PTR().
```

(2).删除使用 device_create 函数创建的设备

```
void device_destroy(struct class *class, dev_t devt)
```

(3).除了使用代码创建设备节点,还可以使用mknod命令创建设备节点

```
用法：mknod 设备名 设备类型 主设备号 次设备号
当类型为”p”时可不指定主设备号和次设备号，否则它们是必须指定的。如果主设备号和次设
备号以”0x”或”0X”开头，它们会被视作十六进制数来解析；如果以”0”开头，则被视作八
进制数；其余情况下被视作十进制数。可用的当类型为”p”时可不指定主设备号和次设备号，否则它们是必须指定的。如果主设备号和次设
备号以”0x”或”0X”开头，它们会被视作十六进制数来解析；如果以”0”开头，则被视作八
进制数；其余情况下被视作十进制数。可用的类型包括：
• b 创建 (有缓冲的) 区块特殊文件
• c, u 创建 (没有缓冲的) 字符特殊文件
• p 创建先进先出 (FIFO) 特殊文件
如：mkmod /dev/test c 2 0
创建一个字符设备/dev/test，其主设备号为 2，次设备号为 0。包括：
• b 创建 (有缓冲的) 区块特殊文件
• c, u 创建 (没有缓冲的) 字符特殊文件
• p 创建先进先出 (FIFO) 特殊文件
如：mkmod /dev/test c 2 0
创建一个字符设备/dev/test，其主设备号为 2，次设备号为 0。
当我们使用上述命令，创建了一个字符设备文件时，实际上就是创建了一个设备节点 inode 结构
体，并且将该设备的设备编号记录在成员 i_rdev，将成员 f_op 指针指向了 def_chr_fops 结构体。有一个函数,init_special_inode函数(内核源码/fs/inode.c)会判断文件的inode类型,如果是字符设备,则把def_chr_fops结构体作为该文件的操作接口,并把设备号记录在inode->i_rdev, inode上的file_operation并不是自己构造的file_operation,而是字符设备通用的def_chr_fops,那么自己构建的 file_operation 等在应用程序调用 open 函数之后，才会绑定在文件上,即新建的 file 结构体的成员 f_op 就指向了 def_chr_fops。

使用命令 rmmod，卸载内核模块，并且删除相应的设备文件:
rmmod chrdev.ko
rm /dev/chrdev
```



用户空间使用 open() 系统调用函数打开一个字符设备时 (int fd = open(“dev/xxx”, O_RDWR)) 大致有以下过程：
• 在虚拟文件系统 VFS 中的查找对应与字符设备对应 struct inode 节点
• 遍历散列表 cdev_map，根据 inod 节点中的 cdev_t 设备号找到 cdev 对象
• 创建 struct file 对象 (系统采用一个数组来管理一个进程中的多个被打开的设备，每个文件秒速符	作为数组下标标识了一个设备对象)
• 初始化 struct file 对象，将 struct file 对象中的 file_operations 成员指向 struct cdev 对象中的   	file_operations 成员 (file->fops = cdev->fops)
• 回调 file->fops->open 函数我们使用的 open 函数

![image-20231215174624222](C:\Users\DELL\Desktop\Linux_code\Typora_Work\Typora_Pic\image-20231215174624222.png)

# 平台设备驱动

平台设备驱动是专用于平台总线的设备，而传统的总线设备，比如 I2C 或者 SPI 设备是平台设备，依赖的是 I2C 或者 SPI 总线。

平台驱动  platform_driver 结构体

```
struct platform_driver
{
	int (*probe)(struct platform_device *);
	int (*remove)(struct platform_device *);
	struct device_driver driver;
	const struct platform_device_id *id_table;
};


struct platform_device_id 
{
	char name[PLATFORM_NAME_SIZE];
	kernel_ulong_t driver_data;
};
第一个是数组用于指定驱动的名称，总线进行
匹配时，会依据该结构体的 name 成员与 platform_device 中的变量 name 进行比较匹配，另一个成
员变量 driver_data，则是用于来保存设备的配置。我们知道在同系列的设备中，往往只是某些寄
存器的配置不一样，为了减少代码的冗余，尽量做到一个驱动可以匹配多个设备的目的。
```

平台设备结构体struct platform_device

```
struct platform_device
{
	const char *name;
	int id;
	struct device dev;   Linux 设备模型中的 device 结构体，linux 内核大量使用了面向对象思想，platform_device
通过继承该结构体可复用它的相关代码，方便内核管理平台设备；
	u32 num_resources;
	struct resource *resource;硬件信息，使用结构体来保存设备所提供的资源，比如设备使用的中断编号，寄存器物理地址等
	const struct platform_device_id *id_entry;
	...........

};


struct resource 
{
    resource_size_t start;
    resource_size_t end;
    const char *name;
    unsigned long flags;

    /* 省略部分成员 */
};
flags：用于指定该资源的类型，在 Linux 中，资源包括 I/O Memory、Register、IRQ、DMA、Bus 等多种类型，最常见的有以下几种：
IORESOURCE_IO 	用于 IO 地址空间，对应于 IO 端口映射方式
IORESOURCE_MEM	用于外设的可直接寻址的地址空间
IORESOURCE_IRQ	用于指定该设备使用某个中断
IORESOURCE_DMA	用于指定使用的 DMA 通道
```

平台总线

```
struct bus_type platform_bus_type =
{
	.name = "platform",
	.dev_groups = platform_dev_groups,
	.match = platform_match,
	.uevent = platform_uevent,
	.pm = &platform_dev_pm_ops,
};
EXPORT_SYMBOL_GPL(platform_bus_type)
```

```
container_of
container_of(inode->icdev, struct led_chrdev, dev)
通过led_chrdev结构体变量中dev成员的地址找到这个结构体变量的首地址

int __must_check kstrtoul_from_user(const char __user *s, size_t count,unsigned int base, unsigned long *res);
函数参数和返回值如下：
参数：
• s：字符串的起始地址，该字符串必须以空字符结尾；
• count： count 为要转换数据的大小；
• base：转换基数，如果 base=0，则函数会自动判断字符串的类型，且按十进制输出，比如“0xa”就会被当做十进制处理 (大小写都一样)，输出为 10。如果是以 0 开头则会被解析为八进制数，否则将会被解析成小数；
• res：一个指向被转换成功后的结果的地址。

内核提供了 kstrtoul_from_user() 函数以实现用户缓冲区到内核缓冲区的拷贝，与之相似的还有copy_to_user()，copy_to_user() 完成的是内核空间缓冲区到用户空 io 间的拷贝。如果你使用的内存类型没那么复杂，便可以选择使用 put_user() 或者 get_user() 函数。
```

# 设备树

```
鲁班猫设备树:
kernel/arch/arm64/boot/dts/rockship/rk3568-2io.dts

DTS、DTC 和 DTB 它们是文档中常见的几个缩写。
• DTS 是指.dts 格式的文件，是一种 ASII 文本格式的设备树描述，也是我们要编写的设备树源码，一般一个.dts 文件对应一个硬件平台，对应 arm 架构，源文件位于 Linux 源码的“/arch/arm/boot/dts”目录下。

• DTC 是指编译设备树源码的工具，一般情况下我们需要手动安装这个编译工具。

• DTB 是设备树源码编译生成的文件，类似于我们 C 语言中“.C”文件编译生成“.bin”文件。

".dtsi" 设备树源文件可以像头文件 (.h 文件) 那样，一个设备树文件引用另外一个设备树文件，这样可以实现“代码”的重用。例如多个硬件平台都使用 rk 系列处理器作为主控芯片，那么我们可以将 rk 系列芯片的硬件资源写到一个单独的设备树文件里面一般使用“.dtsi”后缀，其他板级设备树文件直接使用“# include xxx.dtsi”引用即可。
```



### 查找节点函数

```
1.根据节点路径寻找节点函数
struct device_node *of_find_node_by_path(const char *path)
path：指定节点在设备树中的路径。
device_node：结构体指针，如果查找失败则返回 NULL，否则返回device_node 类型的结构体指针，它保存着设备节点的信息。

2.根据节点名字寻找节点函数
struct device_node *of_find_node_by_name(struct device_node *from,const␣char *name)
from：指定从哪个节点开始查找，它本身并不在查找行列中，只查找它后面的节点，如果设置为 NULL 表示从根节点开始查找。

3.根据节点类型寻找节点函数
struct device_node *of_find_node_by_type(struct device_node *from,const␣char *type)
 type：要查找节点的类型，这个类型就是 device_node-> type。

4.根据节点类型和 compatible 属性寻找节点函数
struct device_node *of_find_compatible_node(struct device_node *from,const␣char *type, const char *compatible)

5. 根据匹配表寻找节点函数
static inline struct device_node *of_find_matching_node_and_match(struct␣device_node *from, const struct of_device_id *matches, const struct of_device_id **match)


6.寻找父节点函数
struct device_node *of_get_parent(const struct device_node *node)
• node：指定谁 (节点) 要查找父节点

7.寻找子节点函数
struct device_node *of_get_next_child(const struct device_node *node,struct device_node *prev)
```



### 提取属性值的of函数

```
1.查找节点属性函数
struct property *of_find_property(const struct device_node *np, const char *name, int *lenp)
name:属性名,lenp获取得到的属性值的大小这个指针作为输出参数，这个参数“带回”的值是实际获取得到的属性大小
返回值:property 结构体，我们把它称为节点属性结构体。失败返回 NULL

2.读取整型属性函数
	读取属性函数是一组函数，分别为读取 8、16、32、64 位数据。	
int of_property_read_u16_array(const struct device_node *np, const char␣propname, u16 *out_values, size_t sz)
• np：指定要读取那个设备节点结构体，也就是说读取那个设备节点的数据。
• propname：指定要获取设备节点的哪个属性。
• out_values：这是一个输出参数，是函数的“返回值”，保存读取得到的数据。
• sz：这是一个输入参数，它用于设置读取的长度。
返回值：
• 返回值，成功返回 0，错误返回错误状态码 (非零值)，-EINVAL(属性不存在)，-ENODATA(没
有要读取的数据)，-EOVERFLOW(属性值列表太小)。

3. 简化后的读取整型属性函数
这里的函数是对读取整型属性函数的简单封装，将读取长度设置为 1。用法与读取属性函数完全一致
//8 位整数读取函数
int of_property_read_u8 (const struct device_node *np, const char *propname,u8 *out_values)

4.读取字符串属性函数
int of_property_read_string(const struct device_node *np,const char␣propname,const char **out_string)
 out_string：获取得到字符串指针，这是一个“输出”参数，带回一个字符串指针。也就是字符串属性值的首地址。这个地址是“属性值”在内存中的真实位置，也就是说我们可以通过对地址操作获取整个字符串属性 (一个字符串属性可能包含多个字符串，这些字符串在内存中连续存储，使用’0’分隔)。
返回值：
• 返回值：成功返回 0，失败返回错误状态码。
这个函数使用相对繁琐，推荐使用下面这个函数:
int of_property_read_string_index(const struct device_node *np,const char␣*propname, int index,const char **out_string)
相比前面的函数增加了参数 index，它用于指定读取属性值中第几个字符串，index 从零开始计数。
第一个函数只能得到属性值所在地址，也就是第一个字符串的地址，其他字符串需要我们手动修改移动地址，非常麻烦，推荐使用第二个函数

5.读取布尔型属性函数
static inline bool of_property_read_bool(const struct device_node *np,␣const char *propname);
返回值：
这个函数不按套路出牌，它不是读取某个布尔型属性的值，仅仅是读取这个属性存在或者不存
在。如果想要或取值，可以使用之前讲解的“全能”函数查找节点属性函数 of_find_property。
```

### 内存映射相关的of函数

```
通常情况下，得到寄存器地址之后我们还要通过 ioremap 函数将物理地址转化为虚拟地址。现在内核提供了 of 函数，自动完成物理地址到虚拟地址的转换。
void __iomem *of_iomap(struct device_node *np, int index)
返回值：
• 成功，得到转换得到的地址。失败返回 NULL。
内核也提供了常规获取地址的 of 函数，这些函数得到的值就是我们在设备树中设置的地址值。介
绍如下：
int of_address_to_resource(struct device_node *dev, int index, struct␣
resource *r)
r：这是一个 resource 结构体，是“输出参数”用于返回得到的地址信息。
• 成功返回 0，失败返回错误状态码。
```



### 实验

```
查看板卡的设备树
ls -l /boot
有个软链接
内核编译设备树：
编译内核时会自动编译设备树，编译内核很耗时，所以我们推荐使用如下命令只编译设备树：
make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- lubancat2_defconfig
make ARCH=arm64 -j4 CROSS_COMPILE=aarch64-linux-gnu- dtbs
编译成功后生成的设备树文件 (.dtb) 位于源码目录下的 arch/arm64/boot/dts/rockchip/，文件名为“rk3568-lubancat2.dtb”



/* 添加 led_test 节点 */
get_dts_info_test: get_dts_info_test
{
    compatible = "get_dts_info_test";
    #address-cells = <1>;
    #size-cells = <1>;
    led@0xfdd60000
    {
    //GPIO0 基地址 0xfdd60000
    compatible = "fire,led_test";
    reg = <0xfdd60000 0x00000100>;
    status = "okay";
    };
};


设备树中的设备树节点在文件系统中有与之对应的文件，位于“/proc/device-tree”目录:
ls /proc/device-tree



原始307
//	leds: leds {
//		status = "okay";
//		compatible = "gpio-leds";
//
//		led0: led0 {
//			label = "heartbeat";
//			linux,default-trigger = "heartbeat";
//			default-state = "on";
//			gpios = <&gpio4 RK_PD2 GPIO_ACTIVE_LOW>;
//			pinctrl-names = "default";
//			pinctrl-0 = <&led0_pin>;
//		};
```

```
1
/* 添加 led_test 节点 */
2
led_test: led_test {
3
status = "okay";
4
compatible = "fire,led_test";
5
default-state = "on";
6
gpios = <&gpio4 RK_PD2 GPIO_ACTIVE_HIGH>;
7
pinctrl-names = "default";
8
pinctrl-0 = <&led_test_pin>;
9
};



```



# 中断子系统

设备树对整个中断系统信息的描述:

kernel/arch/arm64/boot/dts/rockship/rk3568.dtsi

找到"interrupt-controller”节点

![image-20231223095459005](C:\Users\DELL\Desktop\Linux_code\Typora_Work\Typora_Pic\image-20231223095459005.png)

compatible:用于平台设备驱动的匹配

interrupt-controller：声明该设备树节点是一个中断控制器。

#interrupt-cells ：指定使用该中断控制器的节点要用几个 cells 来描述一个中断，可理解为用几个参数来描述一个中断信息。在这里的意思是在 intc 节点的子节点将用 3 个参数来描述中断。

reg: 中断控制器相关寄存器的地址及大小,GICD是Distributor寄存器,

​		 GICR是Redistributor寄存器

interrupts: 描述中断信息，这里是用三个 u32 描述，是前面 #interrupt-cells 指定的。第一个指定中断类型，在 GIC 的中断的类型有三种 (SPI 共享中断、PPI 私有中断、SGI 软件中断)，我们使用的外部中断均属于 SPI 中断类型。

第二个中断号，范围和第一个参数有关。PPI 中断范围是 [0-15]，SPI 中断范围是 [0-256], 第三位是触发类型,数是一个 u32 类型，其中后四位 [0-3] 用于设置中断触发类型。每一位代表一个触发方式，可进行组合，系统提供了相对的宏顶义我们可以直接使用...

its:在 gic 设备节点下，有一个子设备节点 its，ITS 设备用于将消息信号中断 (MSI) 路由到cpu

msi-controller ：标识该设备是 MSI 控制器

#msi-cells ：必须是 1，MSI 设备的 DeviceID

------

## GIC v3中断控制器的代码

```
中断控制器通过IRQCHIP_DECLARE宏注册到__irqchip_of_table
初始化一个 struct of_device_id 的静态常量，并放置在__irqchip_of_table 中

```

API和重要的数据结构

```
中断申请和释放函数
request_irq();
	参数:
	1.irq 内核中断号
	2.handler 中断处理函数
	3.flags 中断触发条件,会覆盖设备树中的默认设置
	4.name 中断的名字,申请成功会在/proc/interrupts目录下看到对应的文件
	5.dev 如果使用了 **IRQF_SHARED** 宏，则开启了共享中断
devm_request_irq() 函数
    此函数与 request_irq() 的区别是 devm_ 开头的 API 申请的是内核“managed”的资源，一般不需要在出错处理和 remove() 接口里再显式的释放。
void free_irq(unsigned int irq, void *dev);

中断处理函数:
irqreturn_t (*irq_handler_t)(int irq, void * dev);

中断的屏蔽和使能:
void enable_irq(unsigned int irq)
void disable_irq(unsigned int irq)

屏蔽或者恢复本 CPU 内的所有中断:
local_irq_enable()
local_irq_disable()
local_irq_save(flags)
local_irq_restore(flags)
```



# SPI驱动学习







# 应用编程

## 1.文件

proc sysfs dev文件系统

sysfs文件系统挂载在/sys

![image-20231019144810417](G:%5CJianYun%5C%E6%88%91%E7%9A%84%E5%9D%9A%E6%9E%9C%E4%BA%91%5CTypora_Work%5CTypora_Pic%5Cimage-20231019144810417.png)

![image-20231019144855956](G:%5CJianYun%5C%E6%88%91%E7%9A%84%E5%9D%9A%E6%9E%9C%E4%BA%91%5CTypora_Work%5CTypora_Pic%5Cimage-20231019144855956.png)

应用层想要对底层硬件进行操控，通常可以通过两种方式：
⚫
/dev/目录下的设备文件（设备节点）；
⚫
/sys/目录下设备的属性文件。
具体使用哪种方式需要根据不同功能类型设备进行选择，有些设备只能通过设备节点进行操控，而有些设备只能通过 sysfs 方式进行操控；当然跟设备驱动具体的实现方式有关，通常情况下，一般简单地设备会使用 sysfs 方式操控，其设备驱动在实现时会将设备的一些属性导出到用户空间 sysfs 文件系统，以属性文件的形式为用户空间提供对这些数据、属性的访问支持，譬如 LED、GPIO 等。
但对于一些较复杂的设备通常会使用设备节点的方式，譬如 LCD 等、触摸屏、摄像头等。

LED设备

此 LED 设备使用的是 Linux 内核标准 LED 驱动框架注册而成，在/dev 目录下并没有其对应的设备节点，其实现使用 sysfs 方式控制。进入到/sys/class/leds 

这里我们主要关注便是 brightness、max_brightness 以及 trigger 三个文件，这三个文件都是 LED 设备的
属性文件：
⚫brightness：翻译过来就是亮度的意思，该属性文件可读可写；所以这个属性文件是用于设置 LED
的亮度等级或者获取当前 LED 的亮度等级，譬如 brightness 等于 0 表示 LED 灭，brightness 为正整
数表示 LED 亮，其值越大、LED 越亮；对于 PWM 控制的 LED 来说，这通常是适用的，因为它存
在亮度等级的问题，不同的亮度等级对应不同的占空比，自然 LED 的亮度也是不同的；但对于 GPIO
控制（控制 GPIO 输出高低电平）的 LED 来说，通常不存在亮度等级这样的说法，只有 LED 亮
（brightness 等于 0）和 LED 灭（brightness 为非 0 值的正整数）两种状态，ALPHA/Mini I.MX6U
开发板上的这颗 LED 就是如此，所以自然就不存在亮度等级一说，只有亮和灭两种亮度等级。
⚫max_brightness：该属性文件只能被读取，不能写，用于获取 LED 设备的最大亮度等级。
⚫trigger：触发模式，该属性文件可读可写，读表示获取 LED 当前的触发模式，写表示设置 LED 的
触发模式。不同的触发模式其触发条件不同，LED 设备会根据不同的触发条件自动控制其亮、灭
状态，通过 cat 命令查看该属性文件，可获取 LED 支持的所有触发模式以及 LED 当前被设置的触
发模式：方括号（[heartbeat]）括起来的表示当前 LED 对应的触发模式，none 表示无触发，常用的触发模式包括
none（无触发）、mmc0（当对 mmc0 设备发起读写操作的时候 LED 会闪烁）、timer（LED 会有规律的一亮一灭，被定时器控制住）、heartbeat（心跳呼吸模式，LED 模仿人的心跳呼吸那样亮灭变化）。

echo命令

```
echo timer > trigger
//将 LED 触发模式设置为 timer
echo none > trigger
//将 LED 触发模式设置为 none
echo 1 > brightness
//点亮 LED echo 0 > brightness//熄灭 LED
```

编写LED程序

```
/*
C 库函数 int fprintf(FILE *stream, const char *format, ...) 发送格式化输出到流 stream 中。
返回值
如果成功，则返回写入的字符总数，否则返回一个负数。
*/
#include <stdio.h>
#include <stdlib.h>

int main()
{
   FILE * fp;

   fp = fopen ("file.txt", "w+");
   fprintf(fp, "%s %s %s %d", "We", "are", "in", 2014);
   
   fclose(fp);
   
   return(0);
}

---> We are in 2014

#include <stdio.h>

int main ()
{
   FILE *fp;
   int c;

   fp = fopen("file.txt","r");
   while(1)
   {
      c = fgetc(fp);
      if( feof(fp) )
      {
          break ;
      }
      printf("%c", c);
   }
   fclose(fp);
   return(0);
}


用主函数传参
int main(int argc, char *argv[])

在使用之前先对交叉编译工具的环境进行设置，使用 source 执行安装目录下的
environment-setup-cortexa7hf-neon-poky-linux-gnueabi 脚本文件即可
source /opt/fsl-imx-x11/4.1.15-2.1.0/environment-setup-cortexa7hf-neon-poky-linux-gnueabi
执行:
./testLED on
./testLED off
./testLED trigger heartbeat 
```

## GPIO应用编程

进入到/sys/class/gpio 目录下

 GPIO1、GPIO2、GPIO3、GPIO4、GPIO5，在这里分别对应 gpiochip0、gpiochip32、
gpiochip64、gpiochip96、gpiochip128

```
echo 0 > export  //导出编号为 0 的 GPIO 引脚
echo 0 > unexport
# 删除导出的编号为 0 的 GPIO 引脚
```



# 驱动编程

### Makefile

开发板光盘->4、参考资料

```
Makefile
main: main.o input.o calcu.o
	gcc -o main main.o input.o calcu.o 
main.o: main.c
	gcc -c main.c
input.o: input.c
	gcc -c input.c
calcu.o: calue.c
	gcc -c calue.c
	
clean:
	rm *.o 
	rm main
	
```

VI/VIM 编辑器使用空格代替了 TAB 键，修改文件/etc/vim/vimrc，在文件最后面加上如
下所示代码：
set noexpandtab

C 语言中的函数调用涉及到出栈入栈，出栈入栈就要
对堆栈进行操作，所谓的堆栈其实就是一段内存，这段内存比较特殊，由 SP 指针访问，SP 指
针指向栈顶。芯片一上电 SP 指针还没有初始化，所以 C 语言没法运行，对于有些芯片还需要
初始化 DDR，因为芯片本身没有 RAM，或者内部 RAM 不开放给用户使用，用户代码需要在
DDR 中运行，因此一开始要用汇编来初始化 DDR 控制器。

### 第7章汇编

### 寄存器

IOMUXC
框 图 里 面 就 有
SW_MUX_CTL_PAD_ 和
SW_PAD_CTL_PAD_两种寄存器。这两种寄存器前面说了用来设置 IO 的复用功能和 IO 属性
配置。

DR 寄存器，此寄存器是数据寄存器

 GDIR 寄存器，这是方向寄存器，用来设置某个 GPIO 的工作方
向的，即输入/输出

 PSR 寄存器，这是 GPIO 状态寄存器

ICR1和 ICR2这两个寄存器，都是中断控制寄存器，ICR1 用于配置低 16个 GPIO，
ICR2 用于配置高 16 个 GPIO

ISR 是中断状态寄存器

EDGE_SEL 寄存器用来设置边沿中断，这个寄存器会覆盖 ICR1 和 ICR2 的设置，同样是一
个 GPIO 对应一个位。如果相应的位被置 1，那么就相当与设置了对应的 GPIO 是上升沿和下降
沿(双边沿)触发





```
linux内核将SOC的I2C适配器(控制器)抽象成 i2c_adaptr

struct i2c_adapter

struct i2c_algorithm


i2c_algorithm 就是 I2C 适
配器与 IIC 设备进行通信的方法

struct i2c_adapter {
	const struct i2c_algorithm *algo; /* the algorithm to access the bus */
	struct device dev;		/* the adapter device */
	unsigned long locked_flags;	/* owned by the I2C core */

	struct i2c_bus_recovery_info *bus_recovery_info;
};


struct i2c_algorithm {
	......
	int (*master_xfer)(struct i2c_adapter *adap,struct i2c_msg *msgs,int num);
	int (*smbus_xfer) (struct i2c_adapter *adap, u16 addr,unsigned short flags, char read_write,u8 command, int size, union i2c_smbus_data *data);

 	/* To determine what the adapter supports */
 	u32 (*functionality) (struct i2c_adapter *);
	......
};
master_xfer 就是 I2C 适配器的传输函数，可以通过此函数来完成与 IIC 设备之间的通信, 



/home/ub20/luckfox_SDK/sysdrv/source/kernel/include/linux/i2c.h





/home/ub20/luckfox_SDK/sysdrv/source/kernel/include/linux/device/bus.h

```

