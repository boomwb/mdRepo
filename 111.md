# 应用编程

## 1.文件

proc sysfs dev文件系统

sysfs文件系统挂载在/sys

![image-20231019144810417](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20231019144810417.png)

![image-20231019144855956](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20231019144855956.png)

应用层想要对底层硬件进行操控，通常可以通过两种方式：
⚫
/dev/目录下的设备文件（设备节点）；
⚫
/sys/目录下设备的属性文件。
具体使用哪种方式需要根据不同功能类型设备进行选择，有些设备只能通过设备节点进行操控，而有些设备只能通过 sysfs 方式进行操控；当然跟设备驱动具体的实现方式有关，通常情况下，一般简单地设备会使用 sysfs 方式操控，其设备驱动在实现时会将设备的一些属性导出到用户空间 sysfs 文件系统，以属性文件的形式为用户空间提供对这些数据、属性的访问支持，譬如 LED、GPIO 等。
但对于一些较复杂的设备通常会使用设备节点的方式，譬如 LCD 等、触摸屏、摄像头等。

LED设备

此 LED 设备使用的是 Linux 内核标准 LED 驱动框架注册而成，在/dev 目录下并没有其对应的设备节点，其实现使用 sysfs 方式控制。进入到/sys/class/leds 

这里我们主要关注便是 brightness、max_brightness 以及 trigger 三个文件，这三个文件都是 LED 设备的
属性文件：
⚫brightness：翻译过来就是亮度的意思，该属性文件可读可写；所以这个属性文件是用于设置 LED
的亮度等级或者获取当前 LED 的亮度等级，譬如 brightness 等于 0 表示 LED 灭，brightness 为正整
数表示 LED 亮，其值越大、LED 越亮；对于 PWM 控制的 LED 来说，这通常是适用的，因为它存
在亮度等级的问题，不同的亮度等级对应不同的占空比，自然 LED 的亮度也是不同的；但对于 GPIO
控制（控制 GPIO 输出高低电平）的 LED 来说，通常不存在亮度等级这样的说法，只有 LED 亮
（brightness 等于 0）和 LED 灭（brightness 为非 0 值的正整数）两种状态，ALPHA/Mini I.MX6U
开发板上的这颗 LED 就是如此，所以自然就不存在亮度等级一说，只有亮和灭两种亮度等级。
⚫max_brightness：该属性文件只能被读取，不能写，用于获取 LED 设备的最大亮度等级。
⚫trigger：触发模式，该属性文件可读可写，读表示获取 LED 当前的触发模式，写表示设置 LED 的
触发模式。不同的触发模式其触发条件不同，LED 设备会根据不同的触发条件自动控制其亮、灭
状态，通过 cat 命令查看该属性文件，可获取 LED 支持的所有触发模式以及 LED 当前被设置的触
发模式：方括号（[heartbeat]）括起来的表示当前 LED 对应的触发模式，none 表示无触发，常用的触发模式包括
none（无触发）、mmc0（当对 mmc0 设备发起读写操作的时候 LED 会闪烁）、timer（LED 会有规律的一亮一灭，被定时器控制住）、heartbeat（心跳呼吸模式，LED 模仿人的心跳呼吸那样亮灭变化）。

echo命令

```
echo timer > trigger
//将 LED 触发模式设置为 timer
echo none > trigger
//将 LED 触发模式设置为 none
echo 1 > brightness
//点亮 LED echo 0 > brightness//熄灭 LED
```

编写LED程序

```
/*
C 库函数 int fprintf(FILE *stream, const char *format, ...) 发送格式化输出到流 stream 中。
返回值
如果成功，则返回写入的字符总数，否则返回一个负数。
*/
#include <stdio.h>
#include <stdlib.h>

int main()
{
   FILE * fp;

   fp = fopen ("file.txt", "w+");
   fprintf(fp, "%s %s %s %d", "We", "are", "in", 2014);
   
   fclose(fp);
   
   return(0);
}

---> We are in 2014

#include <stdio.h>

int main ()
{
   FILE *fp;
   int c;

   fp = fopen("file.txt","r");
   while(1)
   {
      c = fgetc(fp);
      if( feof(fp) )
      {
          break ;
      }
      printf("%c", c);
   }
   fclose(fp);
   return(0);
}


用主函数传参
int main(int argc, char *argv[])

在使用之前先对交叉编译工具的环境进行设置，使用 source 执行安装目录下的
environment-setup-cortexa7hf-neon-poky-linux-gnueabi 脚本文件即可
source /opt/fsl-imx-x11/4.1.15-2.1.0/environment-setup-cortexa7hf-neon-poky-linux-gnueabi
执行:
./testLED on
./testLED off
./testLED trigger heartbeat 
```

## GPIO应用编程

进入到/sys/class/gpio 目录下

 GPIO1、GPIO2、GPIO3、GPIO4、GPIO5，在这里分别对应 gpiochip0、gpiochip32、
gpiochip64、gpiochip96、gpiochip128

```
echo 0 > export  //导出编号为 0 的 GPIO 引脚
echo 0 > unexport
# 删除导出的编号为 0 的 GPIO 引脚
```



# 驱动编程

### Makefile

开发板光盘->4、参考资料

```
Makefile
main: main.o input.o calcu.o
	gcc -o main main.o input.o calcu.o 
main.o: main.c
	gcc -c main.c
input.o: input.c
	gcc -c input.c
calcu.o: calue.c
	gcc -c calue.c
	
clean:
	rm *.o 
	rm main
	
```

VI/VIM 编辑器使用空格代替了 TAB 键，修改文件/etc/vim/vimrc，在文件最后面加上如
下所示代码：
set noexpandtab

C 语言中的函数调用涉及到出栈入栈，出栈入栈就要
对堆栈进行操作，所谓的堆栈其实就是一段内存，这段内存比较特殊，由 SP 指针访问，SP 指
针指向栈顶。芯片一上电 SP 指针还没有初始化，所以 C 语言没法运行，对于有些芯片还需要
初始化 DDR，因为芯片本身没有 RAM，或者内部 RAM 不开放给用户使用，用户代码需要在
DDR 中运行，因此一开始要用汇编来初始化 DDR 控制器。

### 第7章汇编

### 寄存器

IOMUXC
框 图 里 面 就 有
SW_MUX_CTL_PAD_ 和
SW_PAD_CTL_PAD_两种寄存器。这两种寄存器前面说了用来设置 IO 的复用功能和 IO 属性
配置。

DR 寄存器，此寄存器是数据寄存器

 GDIR 寄存器，这是方向寄存器，用来设置某个 GPIO 的工作方
向的，即输入/输出

 PSR 寄存器，这是 GPIO 状态寄存器

ICR1和 ICR2这两个寄存器，都是中断控制寄存器，ICR1 用于配置低 16个 GPIO，
ICR2 用于配置高 16 个 GPIO

ISR 是中断状态寄存器

EDGE_SEL 寄存器用来设置边沿中断，这个寄存器会覆盖 ICR1 和 ICR2 的设置，同样是一
个 GPIO 对应一个位。如果相应的位被置 1，那么就相当与设置了对应的 GPIO 是上升沿和下降
沿(双边沿)触发
