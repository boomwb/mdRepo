# 1.FreeRTOS

## 1.1移植

* v8

- 



`printf`



> hhhe
>
> 

v9

## 1.2创建任务

#### 1.创建任务---SRAM静态内存

#####    **1.定义任务函数**

```
static void LED_Task(void *param)
{
	whiel(1)
	{
		Led1_on;
		vTaskdelay(500);
		led1_off;
		vTaskdealy(500);
	}
任务里面的延时函数必须使用 FreeRTOS 里面提供的延时函数，并
不能使用我们裸机编程中的那种延时。这两种的延时的区别是 FreeRTOS 里面的延时是阻
塞延时，即调用 vTaskDelay()函数的时候，当前任务会被挂起，调度器会切换到其它就绪
的任务，从而实现多任务。如果还是使用裸机编程中的那种延时，那么整个任务就成为了
一个死循环，如果恰好该任务的优先级是最高的，那么系统永远都是在这个任务中运行，
比它优先级更低的任务无法运行，根本无法实现多任务。
}


```

##### 	**2.空闲任务和定时器任务堆栈实现**

```
/* 空闲任务任务堆栈 */
static StackType_t  Idle_Task_Stack[configMINIMAL_STACK_SIZE];
/* 定时器任务堆栈 */
static StackType_tTimer_Task_Stack[configTIMER_TASK_STACK_DEPTH];

并且 我 们需 要 实 现两 个 函数 ：
vApplicationGetIdleTaskMemory()与 vApplicationGetTimerTaskMemory()，

这两个函数是用户设定的空闲（Idle）任务与定时器（Timer）任务的堆栈大小，必须由用户自己分配，而不能是动态分配
```





#####     **3.定义任务栈**

```
/* AppTaskCreate 任务任务堆栈 */
static StackType_t AppTaskCreate_Stack[128];

/* LED 任务堆栈 */
static StackType_t LED_Task_Stack[128];

在 FreeRTOS 系统中，每一个任务都是独立的，他们的运行环境都单独的保存在他们的栈空间当中。那么在定义好任务函数之后，我们还要为任务定义一个栈,，目前我们使用
的是静态内存，所以任务栈是一个独立的全局变量,static StackType_t LED_Task_Stack[128];

任务的栈占用的是 MCU 内部的 RAM，当任务越多的时候，需要使用的栈空间就越大，即需要使用的RAM 空间就越多。一个 MCU 能够支持多少任务，就得看你的 RAM 空间有多少。在大多数系统中需要做栈空间地址对齐，在 FreeRTOS 中是以 8 字节大小对齐，并且会检查堆栈是否已经对齐，其中 portBYTE_ALIGNMENT 是在 portmacro.h 里面定义的一个宏，其值为 8，就是配置为按 8 字节对齐，当然用户可以选择按 1、2、4、8、16、32 等字节对齐，目前默认为 8
```



##### 	4.定义任务控制块

```
/* LED  任务控制块 */
static  StaticTAsk_t  LED_Task_TCB;

```

#####     5.静态创建任务

一个任务的三要素是任务主体函数，任务栈，任务控制块

```
xTaskCreateStatic()
任务使用的栈和任务控制块都是使用静态内存，即预先定义好的全局变量，这些预先定义好的全局变量都存在内部的 SRAM 中。
```

##### 	6.启动任务

任务创建好,是处于就绪态(Ready),在就绪态的任务可以参与操作系统的调度。
但是此时任务仅仅是创建了，还未开启任务调度器，也没创建空闲任务与定时器任务（如果使能了 configUSE_TIMERS 这个宏定义），那这两个任务就是在启动任务调度器中实现，每个操作系统，任务调度器只启动一次，之后就不会再次执行了，FreeRTOS 中启动任务调度器的函数是 vTaskStartScheduler()，并且启动任务调度器的时候就不会返回，从此任务管理都由FreeRTOS 管理，此时才是真正进入实时操作系统中的第一步.

#### 2.创建任务--SRAM动态内存

前面静态创建任务,任务控制块和任务栈的内存空间都是从内部的SRAM分配的,

现在我们使用动态内存,即堆, 其实堆也是内存也属于SRAM.

FreeRTOS 做法是在 SRAM 里面定义一个大数组，
也就是堆内存，供 FreeRTOS 的动态内存分配函数使用，在第一次使用的时候，系统会将定义的堆内存进行初始化，这些代码在 FreeRTOS 提供的内存管理方案中实现（heap_1.c、heap_2.c、heap_4.c 等).

```
//系统所有总的堆大小
#define configTOTAL_HEAP_SIZE ((size_t)(36*1024))

static uint8_t ucHeap[ configTOTAL_HEAP_SIZE ];

/* 如果这是第一次调用 malloc 那么堆将需要初始化，以设置空闲块列表。*/
if ( pxEnd == NULL )
{
  prvHeapInit();

} else
{
	mtCOVERAGE_TEST_MARKER();
}

堆内存的大小为configTOTAL_HEAP_SIZE ， 在
FreeRTOSConfig.h 中由我们自己定义，configSUPPORT_DYNAMIC_ALLOCATION 这个宏
定义在使用 FreeRTOS 操作系统的时候必须开启。
ucHeap:从内部SRAM里面定义一个静态数组 ucHeap，大小由
configTOTAL_HEAP_SIZE 这个宏决定，目前定义为 36KB。定义的堆大小不能超过内部
SRAM 的总大小。
```

1.定义任务函数(与静态相同)

2.定义任务栈
使用动态内存的时候，任务栈在任务创建的时候创建，不用跟使用静态内存那样要预先定义好一个全局的静态的栈空间，动态内存就是按需分配内存，随用随取。

3.定义任务控制块指针

```
//任务句柄
static TaskHandle_t LED_Task_Handler = NULL;
任务句柄是一个指针，用于指向一个任务，当任务创建好之后，它就具有了一个任务句柄以后我们要想操作这个任务都需要通过这个任务句柄，如果是自身的任务操作自己，那么这个句柄可以为 NULL.
```

4.动态创建任务函数

```
xTaskCreate()
```

5.启动任务(与静态相同)

	在创建完任务的时候，我们需要开启调度器，因为创建仅仅是把任务添加到系统中，
	还没真正调度，并且空闲任务也没实现，定时器任务也没实现，这些都是在开启调度函数
	vTaskStartScheduler()中实现的。为什么要空闲任务？因为 FreeRTOS 一旦启动，就必须要
	保证系统中每时每刻都有一个任务处于运行态（Runing），并且空闲任务不可以被挂起与
	删除，空闲任务的优先级是最低的，以便系统中其他任务能随时抢占空闲任务的 CPU 使用
	权。这些都是系统必要的东西，也无需用户自己实现，FreeRTOS 全部帮我们搞定了。处理
	完这些必要的东西之后，系统才真正开始启动，


​	
当创建的应用任务的优先级比 AppTaskCreate 任务的优先级高、低或者相等时候，程序是如何执行的？假如像我们代码一样在临界区创建任务，任务只能在退出临界区的时候才执行最高优先级任务。假如没使用临界区的话，就会分三种情况：1、应用任务的优先级比初始任务的优先级高，那创建完后立马去执行刚刚创建的应用任务，当应用任务被阻塞时，继续回到初始任务被打断的地方继续往下执行，直到所有应用任务创建完成，最后初始任务把自己删除，完成自己的使命；2、应用任务的优先级与初始任务的优先级一样，那创建完后根据任务的时间片来执行，直到所有应用任务创建完成，最后初始任务把自己删除，完成自己的使命；3、应用任务的优先级比初始任务的优先级低，那创建完后任务不会被执行，如果还有应用任务紧接着创建应用任务，如果应用任务的优先级出现了比初始任务高或者相等的情况，请参考 1 和 2 的处理方式，直到所有应用任务创建完成，最后初始任务把自己删除，完成自己的使命。在启动任务调度器的时候，假如启动成功的话，任务就不会有返回了，假如启动没成功，则通过 LR 寄存器指定的地址退出，在创建AppTaskCreate 任务的时候，任务栈对应 LR 寄存器指向是任务退出函数 prvTaskExitError()，该函数里面是一个死循环，这代表着假如创建任务没成功的话，就会进入死循环，该任务也不会运行。

在 Cortex-M3 架构中，FreeRTOS 为了任务启动和任务切换使用了三个异常：SVC、
PendSV 和 SysTick：
SVC（系统服务调用，亦简称系统调用）用于任务启动，有些操作系统不允许应用程
序直接访问硬件，而是通过提供一些系统服务函数，用户程序使用 SVC 发出对系统服务函
数的呼叫请求，以这种方法调用它们来间接访问硬件，它就会产生一个 SVC 异常。
PendSV（可挂起系统调用）用于完成任务切换，它是可以像普通的中断一样被挂起的，
它的最大特性是如果当前有优先级比它高的中断在运行，PendSV 会延迟执行，直到高优先
级中断执行完毕，这样子产生的 PendSV 中断就不会打断其他中断的运行。
SysTick 用于产生系统节拍时钟，提供一个时间片，如果多个任务共享同一个优先级，
则每次 SysTick 中断，下一个任务将获得一个时间片。关于详细的 SVC、PendSV异常描述，
推荐《Cortex-M3 权威指南》一书的“异常”部分。
这里将 PendSV 和 SysTick 异常优先级设置为最低，这样任务切换不会打断某个中
断服务程序，中断服务程序也不会被延迟，这样简化了设计，有利于系统稳定。有人可能
会问，那 SysTick 的优先级配置为最低，那延迟的话系统时间会不会有偏差？答案是不会
的，因为 SysTick 只是当次响应中断被延迟了，而 SysTick 是硬件定时器，它一直在计时，
这一次的溢出产生中断与下一次的溢出产生中断的时间间隔是一样的，至于系统是否响应
还是延迟响应，这个与 SysTick 无关，它照样在计时。

## 1.3任务管理

1任务

在 FreeRTOS 中，任务可以使用或等待 CPU、使用内存空间等系统资源，并
独 立 于 其 它 任 务 运 行 ， 任 何 数 量 的 任 务 可 以 共 享 同 一 个 优 先 级 ， 如 果 宏
configUSE_TIME_SLICING 定义为 1，处于就绪态的多个相同优先级任务将会以时间片切
换的方式共享处理器。
简而言之： FreeRTOS 的任务可认为是一系列独立任务的集合。每个任务在自己的环
境中运行。在任何时刻，只有一个任务得到运行，FreeRTOS 调度器决定运行哪个任务。调
度器会不断的启动、停止每一个任务，宏观看上去所有的任务都在同时在执行。作为任务，
不需要对调度器的活动有所了解，在任务切入切出时保存上下文环境（寄存器值、堆栈内
容）是调度器主要的职责。为了实现这点，每个 FreeRTOS 任务都需要有自己的栈空间。
当任务切出时，它的执行环境会被保存在该任务的栈空间中，这样当任务再次运行时，就
能从堆栈中正确的恢复上次的运行环境，任务越多，需要的堆栈空间就越大，而一个系统
能运行多少个任务，取决于系统的可用的 SRAM。
FreeRTOS 的可以给用户提供多个任务单独享有独立的堆栈空间，系统可以决定任务的
状态，决定任务是否可以运行，同时还能运用内核的 IPC 通信资源，实现了任务之间的通
信，帮助用户管理业务程序流程。这样用户可以将更多的精力投入到业务功能的实现中。
FreeRTOS 中的任务是抢占式调度机制，高优先级的任务可打断低优先级任务，低优先
级任务必须在高优先级任务阻塞或结束后才能得到调度。同时 FreeRTOS 也支持时间片轮
转调度方式，只不过时间片的调度是不允许抢占任务的 CPU 使用权。
任务通常会运行在一个死循环中，也不会退出，如果一个任务不再需要，可以调用
FreeRTOS 中的任务删除 API 函数接口显式地将其删除。

2任务调度器

FreeRTOS 中提供的任务调度器是基于优先级的全抢占式调度：在系统中除了中断处理
函数、调度器上锁部分的代码和禁止中断的代码是不可抢占的之外，系统的其他部分都是
可以抢占的。系统理论上可以支持无数个优先级(0 ～ N，优先级数值越小的任务优先级越低，0 为最低优先级，分配给空闲任务使用，一般不建议用户来使用这个优先级。假如使能了 configUSE_PORT_OPTIMISED_TASK_SELECTION 这个宏（在 FreeRTOSConfig.h 文件定义）

在系统中，当有比当前任务优先
级更高的任务就绪时，当前任务将立刻被换出，高优先级任务抢占处理器运行。

一个操作系统如果只是具备了高优先级任务能够“立即”获得处理器并得到执行的特
点，那么它仍然不算是实时操作系统。因为这个查找最高优先级任务的过程决定了调度时
间是否具有确定性，例如一个包含 n 个就绪任务的系统中，如果仅仅从头找到尾，那么这
个时间将直接和 n 相关，而下一个就绪任务抉择时间的长短将会极大的影响系统的实时性。
FreeRTOS 内核中采用两种方法寻找最高优先级的任务，第一种是通用的方法，在就绪
链表中查找从高优先级往低查找 uxTopPriority，因为在创建任务的时候已经将优先级进行
排序，查找到的第一个 uxTopPriority 就是我们需要的任务，然后通过 uxTopPriority 获取对
应的任务控制块。第二种方法则是特殊方法，利用 计算前导零指令 CLZ，直接在
uxTopReadyPriority 这个 32 位的变量中直接得出 uxTopPriority，这样子就知道哪一个优先
级任务能够运行，这种调度算法比普通方法更快捷，但受限于平台（在 STM32 中我们就使
用这种方法）。
FreeRTOS 内核中也允许创建相同优先级的任务。相同优先级的任务采用时间片轮转方
式进行调度（也就是通常说的分时调度器），时间片轮转调度仅在当前系统中无更高优先
级就绪任务存在的情况下才有效。为了保证系统的实时性，系统尽最大可能地保证高优先
级的任务得以运行。任务调度的原则是一旦任务状态发生了改变，并且当前运行的任务优
先级小于优先级队列组中任务最高优先级时，立刻进行任务切换（除非当前系统处于中断处理程序中或禁止任务切换的状态）。

3.任务状态迁移

FreeRTOS 系统中的每一个任务都有多种运行状态，

![image-20240518163401215](https://raw.githubusercontent.com/boomwb/mdRepo/main/img/202405181634463.png)

图 16-1(1)：创建任务→就绪态（Ready）：任务创建完成后进入就绪态，表明任务已
准备就绪，随时可以运行，只等待调度器进行调度。
图 16-1(2)：就绪态→运行态（Running）：发生任务切换时，就绪列表中最高优先级
的任务被执行，从而进入运行态。
图 16-1(3)：运行态→就绪态：有更高优先级任务创建或者恢复后，会发生任务调度，
此刻就绪列表中最高优先级任务变为运行态，那么原先运行的任务由运行态变为就绪态，
依然在就绪列表中，等待最高优先级的任务运行完毕继续运行原来的任务（此处可以看做
是 CPU 使用权被更高优先级的任务抢占了）。
图 16-1(4)：运行态→阻塞态（Blocked）：正在运行的任务发生阻塞（挂起、延时、
读信号量等待）时，该任务会从就绪列表中删除，任务状态由运行态变成阻塞态，然后发
生任务切换，运行就绪列表中当前最高优先级任务。
图 16-1(5)：阻塞态→就绪态：阻塞的任务被恢复后（任务恢复、延时时间超时、读
信号量超时或读到信号量等），此时被恢复的任务会被加入就绪列表，从而由阻塞态变成
就绪态；如果此时被恢复任务的优先级高于正在运行任务的优先级，则会发生任务切换，
将该任务将再次转换任务状态，由就绪态变成运行态。
图 16-1(6) (7) (8)：就绪态、阻塞态、运行态→挂起态（Suspended）：任务可以通
过调用 vTaskSuspend() API 函数都可以将处于任何状态的任务挂起，被挂起的任务得不到
CPU 的使用权，也不会参与调度，除非它从挂起态中解除。
图 16-1(9)：挂起态→就绪态：把 一 个 挂 起 状态 的 任 务 恢复的 唯 一 途 径 就 是
调 用 vTaskResume() 或 vTaskResumeFromISR() API 函数，如果此时被恢复任务的优先级高
于正在运行任务的优先级，则会发生任务切换，将该任务将再次转换任务状态，由就绪态
变成运行态。

4.任务状态

FreeRTOS 系统中的每一任务都有多种运行状态。系统初始化完成后，创建的任务就可
以在系统中竞争一定的资源，由内核进行调度。
任务状态通常分为以下四种：

就绪（Ready）：该任务在就绪列表中，就绪的任务已经具备执行的能力，只等
待调度器进行调度，新创建的任务会初始化为就绪态。

运行（Running）：该状态表明任务正在执行，此时它占用处理器，FreeRTOS 调
度器选择运行的永远是处于最高优先级的就绪态任务，当任务被运行的一刻，它
的任务状态就变成了运行态。

阻塞（Blocked）：如果任务当前正在等待某个时序或外部中断，我们就说这个任
务处于阻塞状态，该任务不在就绪列表中。包含任务被挂起、任务被延时、任务
正在等待信号量、读写队列或者等待读写事件等。

挂起态(Suspended)：处于挂起态的任务对调度器而言是不可见的，让一个任务进
入挂起状态的唯一办法就是调用 vTaskSuspend()函数；而 把 一 个 挂 起 状态 的
任 务 恢复的 唯 一 途 径 就 是 调 用 vTaskResume() 或 vTaskResumeFromISR()函
数，我们可以这么理解挂起态与阻塞态的区别，当任务有较长的时间不允许运行
的时候，我们可以挂起任务，这样子调度器就不会管这个任务的任何信息，直到
我们调用恢复任务的 API 函数；而任务处于阻塞态的时候，系统还需要判断阻塞
态的任务是否超时，是否可以解除阻塞。

##### 一些API

1.vTaskDelay()

vTaskDelay()用于阻塞延时，调用该函数后，任务将进入阻塞状态，进入阻塞态的任务将让出 CPU 资源。延时的时长由形参 xTicksToDelay 决定，单位为系统节拍周期

vTaskDelay()延时是相对性的延时,它指定的延时时间是从调用 vTaskDelay()结束后开始计算的，经过指定的时间后延时结束。比如 vTaskDelay(100)， 从调用 vTaskDelay()结束
后，任务进入阻塞状态，经过 100 个系统时钟节拍周期后，任务解除阻塞。因此，
vTaskDelay()并不适用与周期性执行任务的场合。此外，其它任务和中断活动， 也会影响
到 vTaskDelay()的调用（比如调用前高优先级任务抢占了当前任务），进而影响到任务的下一次执行的时间，

2.vTaskDelayUntil()

绝对延时函数,这个绝
对延时常用于较精确的周期运行任务，比如我有一个任务，希望它以固定频率定期执行，而不受外部的影响，任务从上一次运行开始到下一次运行开始的时间间隔是绝对的，而不是相对的，

##### 任务的设计要点

FreeRTOS 中程序运行的上下文包括：

中断服务函数。

普通任务。

空闲任务。
1.
中断服务函数：
中断服务函数是一种需要特别注意的上下文环境，它运行在非任务的执行环境下（一
般为芯片的一种特殊运行模式（也被称作特权模式）），在这个上下文环境中不能使用挂
起当前任务的操作，不允许调用任何会阻塞运行的 API 函数接口。另外需要注意的是，中
断服务程序最好保持精简短小，快进快出，一般在中断服务函数中只做标记事件的发生，
然后通知任务，让对应任务去执行相关处理，因为中断服务函数的优先级高于任何优先级
的任务，如果中断处理时间过长，将会导致整个系统的任务无法正常运行。所以在设计的
时候必须考虑中断的频率、中断的处理时间等重要因素，以便配合对应中断处理任务的工
作。
2.
任务：
任务看似没有什么限制程序执行的因素，似乎所有的操作都可以执行。但是做为一个
优先级明确的实时系统，如果一个任务中的程序出现了死循环操作（此处的死循环是指没
有阻塞机制的任务循环体），那么比这个任务优先级低的任务都将无法执行，当然也包括
了空闲任务，因为死循环的时候，任务不会主动让出 CPU，低优先级的任务是不可能得

CPU 的使用权的，而高优先级的任务就可以抢占 CPU。这个情况在实时操作系统中是必须
注意的一点，所以在任务中不允许出现死循环。如果一个任务只有就绪态而无阻塞态，势
必会影响到其他低优先级任务的执行，所以在进行任务设计时，就应该保证任务在不活跃
的时候，任务可以进入阻塞态以交出 CPU 使用权，这就需要我们自己明确知道什么情况下
让任务进入阻塞态，保证低优先级任务可以正常运行。在实际设计中，一般会将紧急的处
理事件的任务优先级设置得高一些。
3.
空闲任务：
空闲任务（idle 任务）是 FreeRTOS 系统中没有其他工作进行时自动进入的系统任务。
因为处理器总是需要代码来执行——所以至少要有一个任务处于运行态。FreeRTOS 为了保
证这一点，当调用 vTaskStartScheduler()时，调度器会自动创建一个空闲任务，空闲任务是
一个非常短小的循环。用户可以通过空闲任务钩子方式，在空闲任务上钩入自己的功能函
数。通常这个空闲任务钩子能够完成一些额外的特殊功能，例如系统运行状态的指示，系
统省电模式等。除了空闲任务钩子，FreeRTOS 系统还把空闲任务用于一些其他的功能，比
如当系统删除一个任务或一个动态任务运行结束时，在执行删除任务的时候，并不会释放
任务的内存空间，只会将任务添加到结束列表中，真正的系统资源回收工作在空闲任务完
成，空闲任务是唯一一个不允许出现阻塞情况的任务，因为 FreeRTOS 需要保证系统永远
都有一个可运行的任务。
对于空闲任务钩子上挂接的空闲钩子函数，它应该满足以下的条件：

永远不会挂起空闲任务；

不应该陷入死循环，需要留出部分时间用于系统处理系统资源回收。
4.
任务的执行时间：
任务的执行时间一般是指两个方面，一是任务从开始到结束的时间，二是任务的周期。
在系统设计的时候这两个时间候我们都需要考虑，例如，对于事件 A 对应的服务任务Ta，系统要求的实时响应指标是 10ms，而 Ta 的最大运行时间是 1ms，那么 10ms 就是任务Ta 的周期了，1ms 则是任务的运行时间，简单来说任务 Ta 在 10ms 内完成对事件 A 的响应即可。此时，系统中还存在着以 50ms 为周期的另一任务 Tb，它每次运行的最大时间长度是 100us。在这种情况下，即使把任务 Tb 的优先级抬到比 Ta 更高的位置，对系统的实时性指标也没什么影响，因为即使在 Ta 的运行过程中，Tb 抢占了 Ta 的资源，等到 Tb 执行完毕，消耗的时间也只不过是 100us，还是在事件 A 规定的响应时间内(10ms)，Ta 能够安全完成对事件 A 的响应。但是假如系统中还存在任务 Tc，其运行时间为 20ms，假如将 Tc的优先级设置比 Ta 更高，那么在 Ta 运行的时候，突然间被 Tc 打断，等到 Tc 执行完毕，那 Ta 已经错过对事件 A（10ms）的响应了，这是不允许的。所以在我们设计的时候，必须考虑任务的时间，一般来说处理时间更短的任务优先级应设置更高一些。

## 1.4消息队列,信号量,互斥量

1.消息队列

消息队列是一种异步的通信方式

2.

- 信号量

- 二值信号量:

	信号量资源被获取,信号量值就是0, 被释放值就是1 

	应用场景:
	轮询查询某标志位有没有被置位时, 这种做法很消耗CPU, 就可以使用二进制信号量实现这种**同步**, 当任务取信号量时，因为此时尚未发生特定事件，信号量为空，任务会进入阻塞状态；当事件的条件满足后，任务/中断便会释放信号量，告知任务这个事件发生了，任务取得信号量便被唤醒去执行对应的操作，任务执行完毕并不需要归还信号量，这样子的 CPU 的效率可以大大提高，而且实时响应也是最快的。

3.互斥信号量

互斥信号量其实是特殊的二值信号量，由于其特有的优先级继承机制从而使它更适用于简单互锁，也就是保护临界资源（什么是优先级继承在后续相信讲解）。
用作互斥时，信号量创建后可用信号量个数应该是满的，任务在需要使用临界资源时，
（临界资源是指任何时刻只能被一个任务访问的资源），先获取互斥信号量，使其变空，
这样其他任务需要使用临界资源时就会因为无法获取信号量而进入阻塞，从而保证了临界
资源的安全。



## 1.5事件

## 1.6软件定时器

## 1.7任务管理

## 1.8内存管理

## 1.9中断管理

## 1.10CPU使用率



